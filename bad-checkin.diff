diff --git a/python/Echomesh.py b/python/Echomesh.py
index cfc50d1..1501f30 100755
--- a/python/Echomesh.py
+++ b/python/Echomesh.py
@@ -4,13 +4,18 @@ from contextlib import closing

 from command import Processor
 from command import Router
+
 from config import Config
+
 from graphics import Display
 from graphics import Tasks
 from graphics import ImagePath
+
 from network import Clients
 from network import Discovery
+
 from sound import Microphone
+# from sound import Sound

 from util import Log
 from util import Openable
@@ -58,6 +63,7 @@ class Echomesh(Openable.Openable):
       self.discovery.close()
       self.mic_thread.close()
       self.display.close()
+      # Sound.close()
       self._join()

   def _join(self):
diff --git a/python/graphics/Display.py b/python/graphics/Display.py
index e27bdd8..88fdd6e 100644
--- a/python/graphics/Display.py
+++ b/python/graphics/Display.py
@@ -1,11 +1,12 @@
 from __future__ import absolute_import, division, print_function, unicode_literals

 import pygame
+import traceback

 from util import Log
 from util import ThreadLoop

-LOGGING = Log.logger(__name__)
+LOGGER = Log.logger(__name__)

 def _make_screen(config):
   dconf = config['display']
@@ -60,23 +61,29 @@ class Display(ThreadLoop.ThreadLoop):
   def remove_client(self, client):
     self.update_clients.remove(client)

-  def runnable(self):
+  def run(self):
+    assert self.is_open
     for c in self.update_clients:
       c.update(self.time)

     if not self.screen:
       return

-    for e in pygame.event.get():
-      if e.type == pygame.QUIT or (e.type == pygame.KEYDOWN and
-                                   e.key == pygame.K_ESCAPE):
-        self.close()
-        return
-
-    self.sprites.update(self.time)
-    pygame.display.update(self.sprites.draw(self.screen))
-    self.time += self.clock.tick(self.config['frames_per_second'])
+    try:
+       for e in pygame.event.get():
+         if e.type == pygame.QUIT or (e.type == pygame.KEYDOWN and
+                                      e.key == pygame.K_ESCAPE):
+           self.close()
+           return
+
+       self.sprites.update(self.time)
+       pygame.display.update(self.sprites.draw(self.screen))
+       self.time += self.clock.tick(self.config['frames_per_second'])
+    except:
+      self.close()
+      LOGGER.critical(traceback.format_exc())

   def close(self):
+    print('closing!')
     ThreadLoop.ThreadLoop.close(self)
     pygame.quit()
diff --git a/python/network/Discovery.py b/python/network/Discovery.py
index 92c26ca..10a430b 100755
--- a/python/network/Discovery.py
+++ b/python/network/Discovery.py
@@ -23,8 +23,6 @@ class Discovery(Openable.Openable):

     self.callbacks = callbacks

-    self.is_running = True
-
     port = self.config['discovery']['port']
     self.receive_socket = Broadcast.ReceiveSocket(port)
     self.send_socket = Broadcast.SendSocket(port)
diff --git a/python/sound/Microphone.py b/python/sound/Microphone.py
index 082fec3..6f5ac11 100644
--- a/python/sound/Microphone.py
+++ b/python/sound/Microphone.py
@@ -10,6 +10,8 @@ from util import Platform
 from util import ThreadLoop
 from util import Util

+from sound import Sound
+
 LOGGING = Log.logger(__name__)

 DEFAULT_CARD_FORMAT = 'sysdefault:CARD=%s'
@@ -33,8 +35,8 @@ def mic_input_alsa(config, rate):

   return lambda: stream.read()

-def _make_stream(pyaud, rate, index):
-  return pyaud.open(
+def _make_stream(rate, index):
+  return Sound.PYAUDIO.open(
     format=pyaudio.paInt16,  # TODO: move this into config.
     channels=1,
     rate=rate,
@@ -43,22 +45,21 @@ def _make_stream(pyaud, rate, index):


 # TODO: a better way to identify that stream.
-def _get_pyaudio_stream(pyaud, rate, use_default=False):
+def _get_pyaudio_stream(rate, use_default=False):
   if use_default:
-    index = pyaud.get_default_input_device_info()['index']
+    index = Sound.PYAUDIO.get_default_input_device_info()['index']
     return _make_stream(pyaud, rate, index)
   else:
     for i in range(MAX_INPUT_DEVICES):
       try:
-        return _make_stream(pyaud, rate, i)
+        return _make_stream(rate, i)
       except:
         pass

   LOGGING.error("Coudn't create pyaudio input stream %d", rate)

 def mic_input_pyaudio(config, rate):
-  pyaud = pyaudio.PyAudio()
-  stream = _get_pyaudio_stream(pyaud, rate)
+  stream = _get_pyaudio_stream(rate)
   if stream:
     chunksize = config['audio']['input'].get('chunksize', DEFAULT_CHUNK_SIZE)
     return lambda: (-1, stream.read(chunksize))
diff --git a/python/unused/ControlLoop.py b/python/unused/ControlLoop.py
index 2df99ee..3ab0cb4 100644
--- a/python/unused/ControlLoop.py
+++ b/python/unused/ControlLoop.py
@@ -13,7 +13,7 @@ class ControlLoop(ThreadLoop.ThreadLoop):
     self.clock = clock
     self.tasks = []

-  def runnable(self):
+  def run(self):
     now = time.time()
     tasks = []
     for task in self.tasks:
diff --git a/python/util/ThreadLoop.py b/python/util/ThreadLoop.py
index 06072c8..d239848 100644
--- a/python/util/ThreadLoop.py
+++ b/python/util/ThreadLoop.py
@@ -9,12 +9,19 @@ from util import Openable
 LOGGER = Log.logger(__name__)

 class ThreadLoop(Openable.Openable):
-  def __init__(self, runnable=None, openable=None):
+  def __init__(self, run=None, openable=None):
     Openable.Openable.__init__(self)
     self.openable = openable or self
-    if runnable:
-      self.runnable = runnable
-    self.thread = threading.Thread(target=self.run)
+    if run:
+      self.run = run
+    else:
+      assert self.run
+    self.thread = threading.Thread(target=self._run)
+
+  def close(self):
+    Openable.Openable.__init__(self)
+    if self is not self.openable:
+      self.openable.close()

   def start(self):
     self.thread.start()
@@ -22,10 +29,11 @@ class ThreadLoop(Openable.Openable):
   def join(self):
     self.thread.join()

-  def run(self):
+  def _run(self):
     try:
-      while self.is_open:
-        self.runnable()
+      while self.openable.is_open:
+        self.run()
     except:
       print(traceback.format_exc())
       self.close()
+      raise
